<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Sharingan Launcher</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <audio id="easter-audio" src="assets/dartacan.mp3" preload="auto"></audio>

  <!-- Pantalla de Intro -->
  <div id="intro-screen">
    <div class="intro-content">
      <img src="assets/icon.png" alt="Logo" class="intro-logo">
      <h1 class="intro-title">Sharingan Launcher</h1>
    </div>
    <audio id="intro-audio" src="assets/intro.mp3"></audio>
  </div>

  <div id="notification-container"></div>

  <div class="app">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-title">Sharingan Launcher</div>
      <ul>
        <li class="active" onclick="showSection('popular', this)">Juegos populares</li>
        <li onclick="showSection('library', this)">Mi biblioteca</li>
        <li onclick="showSection('completed', this)">Juegos pasados</li>
      </ul>
    </aside>

    <!-- Contenido principal -->
    <main class="main-content">
      <!-- Populares / b√∫squeda -->
      <section id="popular" class="section active">
        <h2 class="section-title">Juegos populares</h2>
        <input type="text" id="searchInput" placeholder="Buscar juegos..." oninput="onSearchInput()" />
        <div id="gamesList" class="cards-grid"></div>
      </section>

      <!-- Biblioteca -->
      <section id="library" class="section">
        <div class="library-header">
          <h2 class="section-title" id="libraryTitle">Juegos (0)</h2>

          <button id="linkedFilterBtn" class="filter-btn" onclick="toggleLinkedFilter()">Vinculados</button>

          <button class="filter-btn importBtn" onclick="openImportModal()">
            Importar instalados
          </button>
        </div>

        <div id="libraryList" class="cards-grid"></div>
      </section>

      <!-- Pasados -->
      <section id="completed" class="section">
        <h2 class="section-title">Juegos pasados</h2>
        <div id="completedList" class="cards-grid"></div>
      </section>
    </main>
  </div>

  <script src="node_modules/sweetalert2/dist/sweetalert2.all.min.js"></script>

  <script>
    // ===============================
    // Variables globales
    // ===============================
    let gamesTemp = [];
    let libraryIds = new Set();
    let currentSearchGames = [];
    let showOnlyLinked = false;
    let libraryGamesCache = [];
    let dartacanPlayed = false;

    // Gamepad state
    let activePadIndex = null;
    let gpLast = {
      up:false, down:false, left:false, right:false,
      a:false, b:false, x:false, y:false,
      lb:false, rb:false
    };
    let focusedIndex = 0;
    let focusedContainerId = "gamesList"; // cambia seg√∫n secci√≥n

    // ===============================
    // Navegaci√≥n lateral
    // ===============================
    function showSection(id, el) {
      document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
      document.getElementById(id).classList.add("active");

      document.querySelectorAll(".sidebar li").forEach(li => li.classList.remove("active"));
      if (el) el.classList.add("active");

      // al cambiar secci√≥n, reinicia foco al primer elemento del grid
      if (id === "popular") focusedContainerId = "gamesList";
      if (id === "library") focusedContainerId = "libraryList";
      if (id === "completed") focusedContainerId = "completedList";
      focusedIndex = 0;
      updateGamepadFocus(true);
    }

    function getActiveSectionId() {
      const el = document.querySelector(".section.active");
      return el?.id || "popular";
    }

    // ===============================
    // Carga inicial (UNIFICADA)
    // ===============================
    window.addEventListener("DOMContentLoaded", async () => {
      // filtro biblioteca
      const savedFilter = localStorage.getItem("libraryLinkedFilter");
      showOnlyLinked = savedFilter === "true";

      // intro
      const introScreen = document.getElementById('intro-screen');
      const introAudio = document.getElementById('intro-audio');

      try {
        introAudio.volume = 0.5;
        await introAudio.play();
      } catch (err) {
        console.warn("Audio bloqueado o no encontrado:", err);
      }

      // carga datos
      const loadPromises = Promise.all([loadLibrary(), loadPopularGames()]);

      setTimeout(async () => {
        await loadPromises;
        introScreen.classList.add('hidden');
        setTimeout(() => introScreen.remove(), 500);

        // foco inicial mando
        focusedContainerId = "gamesList";
        focusedIndex = 0;
        updateGamepadFocus(true);
      }, 2000);

      // gamepad loop
      setupGamepad();
    });

    // Cerrar dropdowns al hacer click fuera
    window.addEventListener('click', (e) => {
      if (!e.target.matches('.more-btn')) {
        document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show'));
      }
    });

    // ===============================
    // Populares / b√∫squeda IGDB
    // ===============================
    let lastSearchTimeout = null;

    function onSearchInput() {
      const q = document.getElementById("searchInput").value.trim();
      // Easter egg: "Dartacan"
      const normalized = q.toLowerCase();
      if (normalized === "dartacan") {
        if (!dartacanPlayed) {
          dartacanPlayed = true;

          const audio = document.getElementById("easter-audio");
          if (audio) {
            audio.currentTime = 0;
            audio.play().catch((err) => {
              console.warn("No se pudo reproducir el easter egg (autoplay/pol√≠tica):", err);
            });
          }
        }
      } else {
        dartacanPlayed = false;
      }
      clearTimeout(lastSearchTimeout);
      lastSearchTimeout = setTimeout(() => {
        if (q.length === 0) loadPopularGames();
        else searchGames(q);
      }, 350);
    }

    async function loadPopularGames() {
      const games = await window.electronAPI.fetchPopularGames();
      currentSearchGames = games || [];
      gamesTemp = [];
      displayGames("gamesList", currentSearchGames, "add");
      updateGamepadFocus(true);
    }

    async function searchGames(query) {
      const games = await window.electronAPI.searchIGDB(query);
      currentSearchGames = games || [];
      gamesTemp = [];
      displayGames("gamesList", currentSearchGames, "add");
      updateGamepadFocus(true);
    }

    // ===============================
    // Biblioteca local
    // ===============================
    async function loadLibrary() {
      let { games, completedGames } = await window.electronAPI.getGames();

      libraryIds.clear();
      if (Array.isArray(games)) games.forEach(g => libraryIds.add(g.id));
      if (Array.isArray(completedGames)) completedGames.forEach(g => libraryIds.add(g.id));

      games = games.slice().sort((a, b) => {
        const ak = (a.sortKey || a.name || '').toString();
        const bk = (b.sortKey || b.name || '').toString();
        return ak.localeCompare(bk, 'es', { sensitivity: 'base' });
      });

      completedGames = completedGames.slice().sort((a, b) => {
        const ak = (a.sortKey || a.name || '').toString();
        const bk = (b.sortKey || b.name || '').toString();
        return ak.localeCompare(bk, 'es', { sensitivity: 'base' });
      });

      libraryGamesCache = games;
      applyLibraryFilter();
      displayGames("completedList", completedGames, "completed");
      updateGamepadFocus(true);
    }

    function refreshSearchUI() {
      gamesTemp = [];
      displayGames("gamesList", currentSearchGames, "add");
      updateGamepadFocus(true);
    }

    // ===============================
    // Acciones
    // ===============================
    async function addFromJson(game) {
      try {
        await window.electronAPI.addGame(game);
        await loadLibrary();
        refreshSearchUI();
        showNotification(`"${game.name}" agregado a la biblioteca correctamente.`);
      } catch (error) {
        console.error(error);
        showNotification(`Error al agregar "${game.name}".`, 'error');
      }
    }

    async function setExecutable(id) {
      try {
        const result = await window.electronAPI.openFileDialog();
        if (result.canceled) return;

        const { value: platform } = await Swal.fire({
          title: '¬øDesde qu√© plataforma se ejecuta?',
          text: 'As√≠ podremos usar guardado en la nube si est√° disponible',
          icon: 'question',
          showCancelButton: true,
          confirmButtonText: 'Aceptar',
          cancelButtonText: 'Cancelar',
          focusConfirm: false,
          customClass: { popup: 'swal-platform-popup' },
          html: `
            <div class="platform-grid">
              <label class="platform-option">
                <input type="radio" name="platform" value="steam" />
                <div class="platform-card">
                  <img src="assets/platform/steam.png" alt="Steam">
                  <span>Steam</span>
                </div>
              </label>

              <label class="platform-option">
                <input type="radio" name="platform" value="epic" />
                <div class="platform-card">
                  <img src="assets/platform/epic.png" alt="Epic Games">
                  <span>Epic Games</span>
                </div>
              </label>

              <label class="platform-option">
                <input type="radio" name="platform" value="gog" />
                <div class="platform-card">
                  <img src="assets/platform/gog.png" alt="GOG">
                  <span>GOG</span>
                </div>
              </label>

              <label class="platform-option">
                <input type="radio" name="platform" value="none" />
                <div class="platform-card">
                  <img src="assets/platform/no.png" alt="Sin plataforma">
                  <span>Sin plataforma</span>
                </div>
              </label>
            </div>
          `,
          preConfirm: () => {
            const checked = document.querySelector('input[name="platform"]:checked');
            if (!checked) {
              Swal.showValidationMessage('Selecciona una opci√≥n');
              return false;
            }
            return checked.value;
          }
        });

        if (!platform) return;

        await window.electronAPI.setExecutable(id, { path: result.filePath, platform });
        await loadLibrary();
        refreshSearchUI();
        showNotification('Ejecutable vinculado correctamente');
      } catch (err) {
        console.error(err);
        showNotification('Error al vincular el ejecutable', 'error');
      }
    }

    async function launchGame(id) {
      try {
        await window.electronAPI.launchGame(id);
      } catch (error) {
        console.error(error);
        showNotification("Error al iniciar el juego.", 'error');
      }
    }

    async function markCompleted(id) {
      await window.electronAPI.markCompleted(id);
      loadLibrary();
    }

    async function returnToLibrary(id) {
      await window.electronAPI.returnToLibrary(id);
      loadLibrary();
    }

    async function removeFromLibrary(id) {
      if (confirm("¬øEst√°s seguro de que quieres eliminar este juego de la biblioteca?")) {
        await window.electronAPI.removeGame(Number(id));
        await loadLibrary();
        refreshSearchUI();
        showNotification("Juego eliminado de la biblioteca.");
      }
    }

    function toggleDropdown(e, id) {
      e.stopPropagation();
      // Cerrar otros dropdowns abiertos
      document.querySelectorAll('.dropdown-content').forEach(d => {
        if (d.id !== `dropdown-${id}`) d.classList.remove('show');
      });
      
      const el = document.getElementById(`dropdown-${id}`);
      if (el) el.classList.toggle('show');
    }

    // ===============================
    // Pintar cards reutilizable
    // ===============================
    function displayGames(containerId, games, mode) {
      const container = document.getElementById(containerId);
      container.innerHTML = "";

      if (!Array.isArray(games)) return;

      if (games.length === 0) {
        if (mode === "library") {
          container.innerHTML = `
            <div class="empty-state">
              <p class="empty-title">Todav√≠a no tienes juegos en tu biblioteca.</p>
              <p class="empty-text">Busca juegos en la secci√≥n de populares y a√±√°delos a tu biblioteca.</p>
              <button class="primary" onclick="showSection('popular', document.querySelector('.sidebar li:nth-child(1)'))">
                Buscar juegos
              </button>
            </div>
          `;
          return;
        }

        if (mode === "completed") {
          container.innerHTML = `
            <div class="empty-state">
              <p class="empty-title">A√∫n no has completado ning√∫n juego.</p>
              <p class="empty-text">Es hora de jugar. Cuando termines un juego podr√°s marcarlo como pasado.</p>
              <button class="primary" onclick="showSection('library', document.querySelector('.sidebar li:nth-child(2)'))">
                Ir a mi biblioteca
              </button>
            </div>
          `;
          return;
        }
      }

      games.forEach(game => {
        const div = document.createElement("div");
        div.className = "game-card";

        const name = game.name || "Sin nombre";
        const safeAttrName = name.replace(/"/g, "&quot;");

        const coverUrl =
          game.coverUrl ||
          (game.cover && game.cover.image_id
            ? `https://images.igdb.com/igdb/image/upload/t_cover_big/${game.cover.image_id}.jpg`
            : "assets/no-cover.png");

        let buttonsHtml = "";

        if (mode === "add") {
          const index = gamesTemp.length;
          gamesTemp.push(game);

          if (libraryIds.has(game.id)) {
            buttonsHtml = `<span class="badge-owned">En tu biblioteca</span>`;
          } else {
            buttonsHtml = `<button class="primary add-btn" data-index='${index}'>Agregar a biblioteca</button>`;
          }
        } else if (mode === "library") {
          const hasExe = !!game.executable;
          const exeStatus = hasExe
            ? `<button class="linked-btn" onclick="confirmUnlink('${game.id}')">Vinculado</button>`
            : `<button onclick="setExecutable('${game.id}')">Vincular</button>`;
          const playButton = hasExe ? `<button class="primary" onclick="launchGame('${game.id}')">Jugar</button>` : '';

          // Dropdown para biblioteca
          buttonsHtml = `
            ${exeStatus}
            ${playButton}
            <div class="action-menu">
              <button class="more-btn" onclick="toggleDropdown(event, '${game.id}')">‚ãØ</button>
              <div id="dropdown-${game.id}" class="dropdown-content">
                 <div class="dropdown-item" onclick="markCompleted('${game.id}')">Marcar como pasado</div>
                 <div class="dropdown-item" onclick="openSortKeyEditor('${game.id}')">Cambiar orden</div>
                 <div class="dropdown-item" onclick="removeFromLibrary('${game.id}')" style="color: #ff6b6b;">Quitar de biblioteca</div>
              </div>
            </div>
          `;
        } else if (mode === "completed") {
          const hasExe = !!game.executable;
          const exeStatus = hasExe
            ? `<button class="linked-btn" onclick="confirmUnlink('${game.id}')">Vinculado</button>`
            : `<button onclick="setExecutable('${game.id}')">Vincular</button>`;
          const playButton = hasExe ? `<button class="primary" onclick="launchGame('${game.id}')">Jugar</button>` : '';
          
          // Texto din√°mico para el men√∫
          const platText = game.isPlatinum ? "Desmarcar Platino" : "Marcar Platino üëë";

          // Si es platino, a√±adimos la clase especial al div principal
          if (game.isPlatinum) {
            div.classList.add("platinum-card");
          }

          // HTML de la corona si es platino
          const crownHtml = game.isPlatinum ? `<div class="platinum-crown">üëë</div>` : '';

          buttonsHtml = `
            ${crownHtml} <!-- Insertamos la corona aqu√≠ -->
            ${exeStatus}
            ${playButton}
            <div class="action-menu">
              <button class="more-btn" onclick="toggleDropdown(event, '${game.id}')">‚ãØ</button>
              <div id="dropdown-${game.id}" class="dropdown-content">
                 <div class="dropdown-item" onclick="togglePlatinum('${game.id}')">${platText}</div>
                 <div class="dropdown-item" onclick="returnToLibrary('${game.id}')">Quitar de pasados</div>
                 <div class="dropdown-item" onclick="openSortKeyEditor('${game.id}')">Cambiar orden</div>
                 <div class="dropdown-item" onclick="removeFromLibrary('${game.id}')" style="color: #ff6b6b;">Quitar de biblioteca</div>
              </div>
            </div>
          `;
        }

        div.innerHTML = `
          <img src="${coverUrl}" alt="${safeAttrName}">
          <h3>${name}</h3>
          <div class="card-actions">${buttonsHtml}</div>
        `;

        container.appendChild(div);
      });
    }

    document.addEventListener('click', e => {
      if (e.target.classList.contains('add-btn')) {
        const idx = Number(e.target.dataset.index);
        if (gamesTemp[idx]) addFromJson(gamesTemp[idx]);
      }
    });

    // ===============================
    // Notificaciones
    // ===============================
    function showNotification(message, type = 'success') {
      const container = document.getElementById('notification-container');
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerText = message;
      container.appendChild(notification);
      setTimeout(() => notification.remove(), 3000);
    }

    // ===============================
    // Filtro biblioteca
    // ===============================
    function toggleLinkedFilter() {
      showOnlyLinked = !showOnlyLinked;
      localStorage.setItem("libraryLinkedFilter", showOnlyLinked);
      applyLibraryFilter();
      updateGamepadFocus(true);
    }

    function applyLibraryFilter() {
      const btn = document.getElementById("linkedFilterBtn");
      btn.classList.toggle("active", showOnlyLinked);

      let gamesToShow = libraryGamesCache;
      if (showOnlyLinked) gamesToShow = libraryGamesCache.filter(g => !!g.executable);

      const title = document.getElementById("libraryTitle");
      title.textContent = `Juegos (${gamesToShow.length})`;

      displayGames("libraryList", gamesToShow, "library");
    }

    async function confirmUnlink(id) {
      const ok = confirm("¬øQuieres desvincular el ejecutable de este juego?");
      if (!ok) return;

      try {
        await window.electronAPI.unlinkExecutable(id);
        await loadLibrary();
        refreshSearchUI();
        showNotification("Ejecutable desvinculado correctamente.");
      } catch (err) {
        console.error(err);
        showNotification("Error al desvincular el ejecutable.", "error");
      }
    }

    async function openSortKeyEditor(id) {
      // Buscar en cach√© global primero
      let game = libraryGamesCache.find(g => String(g.id) === String(id));
      
      // Si no est√°, buscar en estado general (por si estamos en 'completados' y no est√°n en cache de librer√≠a)
      if(!game) {
        const { games, completedGames } = await window.electronAPI.getGames();
        game = games.find(g => String(g.id) === String(id)) || completedGames.find(g => String(g.id) === String(id));
      }

      if (!game) {
        showNotification('No se encontr√≥ el juego.', 'error');
        return;
      }

      const name = game.name || 'Sin nombre';
      const currentSortKey = game.sortKey || name;

      const coverUrl =
        game.coverUrl ||
        (game.cover && game.cover.image_id
          ? `https://images.igdb.com/igdb/image/upload/t_cover_big/${game.cover.image_id}.jpg`
          : "assets/no-cover.png");

      const { value: newSortKey } = await Swal.fire({
        title: 'Nombre para ordenar',
        html: `
          <div class="sortkey-modal">
            <img src="${coverUrl}" alt="${name}" class="sortkey-cover">
            <p>${name}</p>
          </div>
        `,
        input: 'text',
        inputLabel: 'Texto usado para ordenar en la biblioteca',
        inputValue: currentSortKey,
        showCancelButton: true,
        confirmButtonText: 'Guardar',
        cancelButtonText: 'Cancelar'
      });

      if (newSortKey === undefined) return;

      try {
        await window.electronAPI.updateSortKey(id, newSortKey);
        await loadLibrary();
        showNotification('Orden actualizado correctamente.');
      } catch (err) {
        console.error(err);
        showNotification('Error al actualizar el orden.', 'error');
      }
    }

    // ===============================
    // Import modal (sin cambios funcionales)
    // ===============================
    async function openImportModal() {
      const state = {
        steamRoot: null,
        epicManifestsDir: null,
        epicDatDir: null,
        gogRoot: null,
        noneRoot: null
      };

      const esc = (s) => (s ? String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : '');

      function row(title, value, btnId, hint) {
        return `
          <div style="padding:10px; border:1px solid rgba(255,255,255,.08); border-radius:10px;">
            <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
              <div>
                <div><b>${title}</b></div>
                <div style="font-size:12px; opacity:.85; margin-top:6px">${esc(value || '(no seleccionado / auto)')}</div>
                ${hint ? `<div style="font-size:12px; opacity:.7; margin-top:6px">${esc(hint)}</div>` : ''}
              </div>
              <div>
                <button type="button" id="${btnId}" class="swal2-confirm swal2-styled" style="margin:0;">Seleccionar</button>
              </div>
            </div>
          </div>
        `;
      }

      function render() {
        return `
          <div style="text-align:left; display:grid; gap:10px;">
            ${row('Steam', state.steamRoot, 'pickSteam', 'Carpeta ra√≠z de Steam (donde est√° steam.exe)')}
            ${row('Epic', state.epicManifestsDir, 'pickEpic', 'Normalmente: C:\\ProgramData\\Epic\\EpicGamesLauncher\\Data\\Manifests')}
            ${row('GOG (carpeta juegos)', state.gogRoot, 'pickGog', 'Carpeta con subcarpetas (cada subcarpeta = 1 juego)')}
            ${row('Sin plataforma (pirata)', state.noneRoot, 'pickNone', 'Carpeta con subcarpetas (cada subcarpeta = 1 juego)')}
            ${row('Epic LauncherInstalled.dat (opcional)', state.epicDatDir, 'pickEpicDat', 'Normalmente: C:\\ProgramData\\Epic\\UnrealEngineLauncher')}
            <div style="font-size:12px; opacity:.75">
              Nota: Steam/Epic intentan detectar instalados por manifests. GOG/Sin plataforma importan cada subcarpeta como juego y buscan el .exe.
            </div>
          </div>
        `;
      }

      function bindButtons() {
        const popup = Swal.getPopup();
        if (!popup) return;

        const bind = (id, handler) => {
          const el = popup.querySelector('#' + id);
          if (!el) return;
          el.onclick = handler;
        };

        bind('pickSteam', async () => {
          const res = await window.electronAPI.openDirectoryDialog({ title: 'Selecciona la carpeta ra√≠z de Steam' });
          if (!res.canceled) state.steamRoot = res.dirPath;
          Swal.update({ html: render() });
        });

        bind('pickEpic', async () => {
          const res = await window.electronAPI.openDirectoryDialog({ title: 'Selecciona la carpeta Manifests de Epic' });
          if (!res.canceled) state.epicManifestsDir = res.dirPath;
          Swal.update({ html: render() });
        });

        bind('pickEpicDat', async () => {
          const res = await window.electronAPI.openDirectoryDialog({ title: 'Selecciona la carpeta donde est√° LauncherInstalled.dat' });
          if (!res.canceled) state.epicDatDir = res.dirPath;
          Swal.update({ html: render() });
        });

        bind('pickGog', async () => {
          const res = await window.electronAPI.openDirectoryDialog({ title: 'Selecciona la carpeta donde est√°n los juegos de GOG' });
          if (!res.canceled) state.gogRoot = res.dirPath;
          Swal.update({ html: render() });
        });

        bind('pickNone', async () => {
          const res = await window.electronAPI.openDirectoryDialog({ title: 'Selecciona la carpeta de juegos sin plataforma (pirata)' });
          if (!res.canceled) state.noneRoot = res.dirPath;
          Swal.update({ html: render() });
        });
      }

      const result = await Swal.fire({
        title: 'Importar juegos instalados',
        width: 760,
        html: render(),
        showCancelButton: true,
        confirmButtonText: 'Importar',
        cancelButtonText: 'Cancelar',
        focusConfirm: false,
        customClass: { popup: 'import-popup' },
        didRender: () => bindButtons()
      });

      if (!result.isConfirmed) return;

      const epicLauncherInstalledDat = state.epicDatDir
        ? (state.epicDatDir.replace(/\\+$/, '') + '\\LauncherInstalled.dat')
        : null;

      const payload = {
        steamRoot: state.steamRoot,
        epicManifestsDir: state.epicManifestsDir,
        epicLauncherInstalledDat,
        gogRoot: state.gogRoot,
        noneRoot: state.noneRoot
      };

      console.log('IMPORT payload', payload);

      try {
        Swal.fire({ title: 'Importando...', allowOutsideClick: false, didOpen: () => Swal.showLoading() });
        await window.electronAPI.importInstalledGames(payload);

        const enrich = await window.electronAPI.enrichCovers({ limit: 80 });
        console.log('ENRICH', enrich);

        await loadLibrary();
        refreshSearchUI();

        showNotification(`Juegos: ${enrich?.updated ?? 0}/${enrich?.scanned ?? 0} importados`);

        Swal.fire({
          icon: 'success',
          title: 'Importaci√≥n completada',
          text: `Juegos importados correctamente: ${enrich?.updated ?? 0}/${enrich?.scanned ?? 0}`
        });
      } catch (err) {
        console.error(err);
        Swal.fire({ icon: 'error', title: 'Error importando', text: String(err?.message || err) });
      }
    }

    // ===============================
    // GAMEPAD: foco + acciones
    // ===============================
    function setupGamepad() {
      window.addEventListener("gamepadconnected", (e) => {
        activePadIndex = e.gamepad.index;
        showNotification(`Mando conectado`, 'success');
        console.log("Gamepad conectado:", e.gamepad.id, "mapping:", e.gamepad.mapping);
      });

      window.addEventListener("gamepaddisconnected", (e) => {
        if (activePadIndex === e.gamepad.index) activePadIndex = null;
        showNotification(`Mando desconectado`, 'error');
      });

      requestAnimationFrame(tickGamepad);
    }

    function getPad() {
      const pads = navigator.getGamepads?.() || [];
      if (activePadIndex != null && pads[activePadIndex]) return pads[activePadIndex];
      return pads.find(Boolean) || null;
    }

    function edge(now, key) {
      const fired = now && !gpLast[key];
      gpLast[key] = now;
      return fired;
    }

    function getCardsInActiveGrid() {
      const secId = getActiveSectionId();
      if (secId === "popular") return Array.from(document.querySelectorAll("#gamesList .game-card"));
      if (secId === "library") return Array.from(document.querySelectorAll("#libraryList .game-card"));
      if (secId === "completed") return Array.from(document.querySelectorAll("#completedList .game-card"));
      return [];
    }

    function updateGamepadFocus(force = false) {
      const cards = getCardsInActiveGrid();
      cards.forEach(c => c.classList.remove("gp-focused"));

      if (cards.length === 0) return;

      if (focusedIndex < 0) focusedIndex = 0;
      if (focusedIndex >= cards.length) focusedIndex = cards.length - 1;

      const focused = cards[focusedIndex];
      if (focused) {
        focused.classList.add("gp-focused");
        focused.scrollIntoView({ block: "nearest", inline: "nearest", behavior: force ? "auto" : "smooth" });
      }
    }

    function getGridColumns() {
      // aproximaci√≥n: deriva columnas seg√∫n ancho (igual que tu CSS media queries)
      const w = window.innerWidth;
      if (w <= 700) return 2;
      if (w <= 1000) return 3;
      if (w <= 1400) return 4;
      return 6;
    }

    function clickPrimaryActionOnFocused() {
      const cards = getCardsInActiveGrid();
      const card = cards[focusedIndex];
      if (!card) return;

      // Prioridad: bot√≥n primary (Jugar/Agregar)
      const primary = card.querySelector("button.primary");
      if (primary) return primary.click();

      // Si no hay primary, click al primer button normal
      const anyBtn = card.querySelector("button");
      if (anyBtn) return anyBtn.click();
    }

    function backAction() {
      // Si hay un Swal abierto, intenta cerrarlo (escape)
      const popup = Swal.getPopup?.();
      if (popup) {
        Swal.close();
        return;
      }

      // Volver a biblioteca como acci√≥n "atr√°s" sencilla
      showSection('library', document.querySelector('.sidebar li:nth-child(2)'));
    }

    function switchSection(delta) {
      const items = Array.from(document.querySelectorAll(".sidebar li"));
      const activeIdx = items.findIndex(li => li.classList.contains("active"));
      if (activeIdx < 0) return;
      let next = activeIdx + delta;
      if (next < 0) next = items.length - 1;
      if (next >= items.length) next = 0;
      items[next].click();
    }

    function tickGamepad() {
      const gp = getPad();

      if (gp) {
        // Standard mapping indices t√≠picos.
        const up = !!gp.buttons[12]?.pressed || (gp.axes?.[1] ?? 0) < -0.6;
        const down = !!gp.buttons[13]?.pressed || (gp.axes?.[1] ?? 0) > 0.6;
        const left = !!gp.buttons[14]?.pressed || (gp.axes?.[0] ?? 0) < -0.6;
        const right = !!gp.buttons[15]?.pressed || (gp.axes?.[0] ?? 0) > 0.6;

        const a = !!gp.buttons[0]?.pressed; // A / Cross
        const b = !!gp.buttons[1]?.pressed; // B / Circle
        const x = !!gp.buttons[2]?.pressed;
        const y = !!gp.buttons[3]?.pressed;
        const lb = !!gp.buttons[4]?.pressed;
        const rb = !!gp.buttons[5]?.pressed;

        const cols = getGridColumns();

        if (edge(up, "up")) { focusedIndex -= cols; updateGamepadFocus(); }
        if (edge(down, "down")) { focusedIndex += cols; updateGamepadFocus(); }
        if (edge(left, "left")) { focusedIndex -= 1; updateGamepadFocus(); }
        if (edge(right, "right")) { focusedIndex += 1; updateGamepadFocus(); }

        if (edge(a, "a")) clickPrimaryActionOnFocused();
        if (edge(b, "b")) backAction();

        // Cambiar secci√≥n con LB/RB
        if (edge(lb, "lb")) switchSection(-1);
        if (edge(rb, "rb")) switchSection(+1);

        // (Opcional) X para toggle vinculados en biblioteca
        if (edge(x, "x")) {
          if (getActiveSectionId() === "library") toggleLinkedFilter();
        }

        // (Opcional) Y para enfocar buscador si est√°s en populares
        if (edge(y, "y")) {
          if (getActiveSectionId() === "popular") {
            document.getElementById("searchInput")?.focus();
          }
        }
      }

      requestAnimationFrame(tickGamepad);
    }
    async function togglePlatinum(id) {
      try {
        await window.electronAPI.togglePlatinum(id);
        await loadLibrary(); // Recargamos para ver el borde dorado
        // No mostramos notificaci√≥n para que sea una acci√≥n r√°pida, o si quieres:
        // showNotification("Estado de platino actualizado");
      } catch (err) {
        console.error(err);
      }
    }
  </script>
</body>
</html>
